import { Analytics } from '../../core/Analytics';
import VideoCompletionTracker from '../../core/VideoCompletionTracker';
import { Player } from '../../enums/Player';
import { Feature } from '../../features/Feature';
import { FeatureConfig } from '../../features/FeatureConfig';
import { AnalyticsStateMachineOptions } from '../../types/AnalyticsStateMachineOptions';
import { DrmPerformanceInfo } from '../../types/DrmPerformanceInfo';
import { FeatureConfigContainer } from '../../types/FeatureConfigContainer';
import { PlaybackInfo } from '../../types/PlaybackInfo';
import { QualityLevelInfo } from '../../types/QualityLevelInfo';
import { SegmentInfo } from '../../types/SegmentInfo';
import { StreamSources } from '../../types/StreamSources';
import { SubtitleInfo } from '../../types/SubtitleInfo';
import { InternalAdapter } from './InternalAdapter';
import { InternalAdapterAPI } from './InternalAdapterAPI';
export declare abstract class HTML5InternalAdapter extends InternalAdapter implements InternalAdapterAPI {
    protected mediaElement: HTMLVideoElement | null;
    get segments(): SegmentInfo[];
    private static BUFFERING_TIMECHANGED_TIMEOUT;
    mediaElEventHandlers: Array<{
        event: string;
        handler: any;
    }>;
    abstract getPlayerVersion: () => string;
    readonly videoCompletionTracker: VideoCompletionTracker;
    protected needsFirstPlayIntent: boolean;
    private onBeforeUnLoadEvent;
    private bufferingTimeout?;
    private isBuffering;
    private lastIsLiveStatus;
    private isPaused;
    private isSeeking;
    private previousMediaTime;
    private previousClientTime;
    private needsReadyEvent;
    private mediaElementSet;
    constructor(mediaElement: HTMLVideoElement | null, opts?: AnalyticsStateMachineOptions);
    getPlayerName: () => Player;
    getPlayerTech: () => string;
    getAutoPlay: () => boolean;
    getDrmPerformanceInfo: () => DrmPerformanceInfo | undefined;
    initialize(analytics: Analytics): Array<Feature<FeatureConfigContainer, FeatureConfig>>;
    isLive: () => boolean;
    getStreamSources(url: string | undefined): StreamSources;
    getCurrentPlaybackInfo(): PlaybackInfo;
    protected get currentTime(): number;
    /**
     * Used to setup against the media element.
     * We need this method to desynchronize construction of this class
     * and the actual initialization against the media element.
     * That is because at construction some media engine
     * may not already have the media element attached, for example
     * when passing in the DOM element is happening at once with passing the source URL
     * and can not be decoupled.
     * We are then awaiting an event from the engine and calling this with the media element
     * as argument from our sub-class.
     *
     * This method can also be called without arguments and then it will perform
     * initialization against the existing media element (should only be called once, will throw an error otherwise)
     *
     * It can also be used to replace the element.
     *
     *
     */
    setMediaElement(mediaElement?: HTMLVideoElement | null): void;
    abstract getCurrentQualityLevelInfo(): QualityLevelInfo | null;
    /**
     * Can be overriden by sub-classes
     * @returns {string}
     *
     */
    getMIMEType(): string | undefined;
    /**
     * Can be overriden by sub-classes
     * @returns {string}
     */
    getStreamType(): string | undefined;
    /**
     * Can be overriden by subclasses.
     * @returns {string}
     */
    getStreamURL(): string | undefined;
    resetMedia(): void;
    registerMediaElement(): void;
    /**
     * Should only be calld when a mediaElement is attached
     */
    listenToMediaElementEvent(event: any, handler: any): void;
    onMaybeReady(): void;
    /**
     * Should only be calld when a mediaElement is attached
     */
    unregisterMediaElement(): void;
    onBuffering(): void;
    onPaused(currentTime?: number): void;
    registerWindowEvents(): void;
    onPageClose(): void;
    checkPlayheadProgress(): void;
    /**
     * @param {boolean} silent
     */
    checkQualityLevelAttributes(silent?: boolean): void;
    sourceChange(config: any, timestamp: number): void;
    getSelectedSubtitleFromMediaElement(mediaElement: any): SubtitleInfo | undefined;
    private checkSeeking;
}
